#ifndef IMU_CONVERSION_HPP
#define IMU_CONVERSION_HPP  

#include<stdint.h>
#include "../drivers/kx134.hpp"

struct IMU_Data
{
    float x_g;
    float y_g;
    float z_g;

};

/**
 * @brief IMU Conversion Layer
 *
 * Responsible for converting raw KX134 sensor data
 * into physical acceleration values (g).
 *
 * This class:
 *  - Applies scale based on configured range
 *  - Applies calibration offsets
 *  - Performs deterministic conversion
 *  - Does NOT perform I2C communication
 *  - Does NOT perform logging
 *
 * Safe for flight firmware usage.
 */
class IMUConversion
{
    public:
    explicit IMUConversion(KX134_Range range)
    : _range(range),
    _scale(0.0f),
    _x_offset(0),
    _y_offset(0),
    _z_offset(0)
    {
        updateScale();
    }
     /**
     * @brief Set sensor range (updates scale factor)
     */
    void setRange(KX134_Range range)
    {
        _range = range;
        updateScale();
    }

    /**
     * @brief Get current range
     */
    KX134_Range getRange() const
    {
        return _range;
    }

    /**
     * @brief Set calibration offsets (raw units)
     *
     * Offsets are subtracted from raw data before scaling.
     */
    void setOffsets(int16_t x_off, int16_t y_off, int16_t z_off)
    {
        _x_offset = x_off;
        _y_offset = y_off;
        _z_offset = z_off;
    }
    /**
     * @brief Reset offsets to zero
     */
    void clearOffsets()
    {
        _x_offset = 0;
        _y_offset = 0;
        _z_offset = 0;
    }
    /**
     * @brief Convert raw sensor data to physical units (g)
     *
     * @param raw Raw data from KX134 driver
     * @return IMU_Data Acceleration in g
     */
    IMU_Data convert(const KX134_Raw& raw) const
    {
        IMU_Data data;

        // Apply offset correction
        int32_t x_corr = static_cast<int32_t>(raw.x) - _x_offset;
        int32_t y_corr = static_cast<int32_t>(raw.y) - _y_offset;
        int32_t z_corr = static_cast<int32_t>(raw.z) - _z_offset;

        // Scale to physical units
        data.x_g = static_cast<float>(x_corr) * _scale;
        data.y_g = static_cast<float>(y_corr) * _scale;
        data.z_g = static_cast<float>(z_corr) * _scale;

        return data;
    }
      /**
     * @brief Get current scale factor (g per LSB)
     */
    float getScale() const
    {
        return _scale;
    }
private:

    KX134_Range _range;
    float       _scale;

    int16_t _x_offset;
    int16_t _y_offset;
    int16_t _z_offset;

    /**
     * @brief Update scale factor based on range
     *
     * KX134 is 16-bit signed:
     *  Full positive range = 32768 counts
     *
     *  scale = full_scale_g / 32768
     */
    void updateScale()
    {
        float full_scale = 0.0f;

        switch (_range)
        {
            case KX134_Range::RANGE_8G:  full_scale = 8.0f;  break;
            case KX134_Range::RANGE_16G: full_scale = 16.0f; break;
            case KX134_Range::RANGE_32G: full_scale = 32.0f; break;
            case KX134_Range::RANGE_64G: full_scale = 64.0f; break;
        }

        _scale = full_scale / 32768.0f;
    }
};

#endif
