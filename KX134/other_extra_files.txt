imu acqusition layer  - > it says that when and how to get the imu data 
bus is like interface -> it knows how to get the data
task it does-> The IMU acquisition layer controls the sampling behavior and data flow between the driver and the rest of the system
1. initilaises the imu
2. decides when to read -> rules are -> 1. polling, 2. poll when data ready is true, interrupt fire, timer based freq
3. read data safely
4. push into buffer
5. mainain deterministic sampling
---------
coming to the fifo buffer internally present in kx134-1211 -> it can store 512 samples ->
1 sample  = 6 bytes(x,y,z)
so 512 samples  = 3KB

------------

in imu conversion -> lets first print the og data and then after validation , will use efficent methodd while tx to gnd
calibration -> 

reduce fifo size
classes add
fdir -> no infinite loops
plan a test case file -> that does check whether 

while using cpp
lets avoid -> dynamic memnory allocation, no stl, no virtual functions, no heap


i2c low and high pin pullling sda chweck in the bus file

---Higher ODR â†’ more noise

----Lower ODR â†’ smoother

kx134 (Driver)

Raw register communication only.

ðŸ”¹ imu_acquisition

Call driver

Get raw

Call conversion

Return processed struct

ðŸ”¹ imu_conversion

Convert raw â†’ g

ðŸ”¹ data_logger

Format

Timestamp

Print / store

ðŸ”¹ main

Initialize I2C

Create objects

Configure sensor

Loop at 50Hz

Call acquisition

Call logger

-------------------
imu_conversion is the physics layer.

It must:

1ï¸âƒ£ Take raw sensor counts (int16_t)
2ï¸âƒ£ Know what range is configured (8g / 16g / 32g / 64g)
3ï¸âƒ£ Apply correct scale factor
4ï¸âƒ£ Apply calibration offsets (optional but recommended)
5ï¸âƒ£ Output usable physical units

----------------------
imu values dry run--
example  -  64g
raw.x, raw.y, raw.z = (16384, -8192, 3276)
as it is int16 -> range (-32768 to 32767)
scale =  full_scale / 32768 -> 64/ 32768 => 0.001953125g

now lets multiply by raw scale ->  x_g = 16384* 0.001953125 =>  32g
similarly y_g =  -8192*  0.001953125 => -16g
z_g =  3276 *  0.001953125 => 6.39g

Raw int16
   â†“
Subtract offset
   â†“
Multiply by scale
   â†“
Get physical g

after that instead of loat-> send
32.0g * 100 -> 3200 

-----> while working on classes -> explicit declaration will prevent type conversion

converting the 16 bit offset and the imu values to 32 bit while subtraction to  prevent wrap around/ overflow

--------------------------
main.cpp
Initialize stdio

Initialize I2C

Configure GPIO pins

Create KX134 object

Configure sensor

Create IMUConversion (64g)

Loop at 50 Hz

Read raw

Convert

Print structured telemetry

i2c_write_blocking() = once the bus gets locked-> stays locked forever


in main file-> if 1 is present then raw values, if 0  then converted values


